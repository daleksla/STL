<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Salih&#39;s Template Library (STL): salih::algorithms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Salih&#39;s Template Library (STL)
   </div>
   <div id="projectbrief">Salih&#39;s Template Library (STL) is a custom C++ Library inspired by STL (C++&#39;s standard template library), Boost, Common Algorithms / Data structures &amp; Python abstraction</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesalih.html">salih</a></li><li class="navelem"><a class="el" href="namespacesalih_1_1algorithms.html">algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">salih::algorithms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9465eebd27e97b93e21aba605740844"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad9465eebd27e97b93e21aba605740844"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#ad9465eebd27e97b93e21aba605740844">swap</a> (U &amp;, U &amp;)</td></tr>
<tr class="separator:ad9465eebd27e97b93e21aba605740844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107115c85af2697704dc3c5b36fde36d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a107115c85af2697704dc3c5b36fde36d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">ASCEND</a> (U, U)</td></tr>
<tr class="separator:a107115c85af2697704dc3c5b36fde36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d1038265c73db15d7f7b0ead070cc5"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aa8d1038265c73db15d7f7b0ead070cc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">DESCEND</a> (U, U)</td></tr>
<tr class="separator:aa8d1038265c73db15d7f7b0ead070cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7da9a1227add1ebb665f33c309aaa1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#adb7da9a1227add1ebb665f33c309aaa1">getMiddle</a> (const std::size_t size)</td></tr>
<tr class="separator:adb7da9a1227add1ebb665f33c309aaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cfefbba1cc2773a2ea3cdc839d1747"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a58cfefbba1cc2773a2ea3cdc839d1747"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a58cfefbba1cc2773a2ea3cdc839d1747">binarySearch</a> (const T &amp;, const U &amp;)</td></tr>
<tr class="separator:a58cfefbba1cc2773a2ea3cdc839d1747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571825f56776c7964a279acee993857f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a571825f56776c7964a279acee993857f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a571825f56776c7964a279acee993857f">interpolationSearch</a> (const T &amp;, const U &amp;)</td></tr>
<tr class="separator:a571825f56776c7964a279acee993857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad8f696fdcdbeba1793aa531b7f0e0a"><td class="memTemplParams" colspan="2">template&lt;typename UniDirectionalIterator , typename U &gt; </td></tr>
<tr class="memitem:a4ad8f696fdcdbeba1793aa531b7f0e0a"><td class="memTemplItemLeft" align="right" valign="top">_GLIBCXX14_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a4ad8f696fdcdbeba1793aa531b7f0e0a">linearSearch</a> (const UniDirectionalIterator &amp;, const UniDirectionalIterator &amp;, const U &amp;)</td></tr>
<tr class="separator:a4ad8f696fdcdbeba1793aa531b7f0e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644274376f729c02cbfc2e8771688ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a8644274376f729c02cbfc2e8771688ba"><td class="memTemplItemLeft" align="right" valign="top">_GLIBCXX14_CONSTEXPR bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a8644274376f729c02cbfc2e8771688ba">linearSearch</a> (const T &amp;, const U &amp;)</td></tr>
<tr class="separator:a8644274376f729c02cbfc2e8771688ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b96e58917d763e64eb4097c712d109"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12b96e58917d763e64eb4097c712d109"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a12b96e58917d763e64eb4097c712d109">bubbleSort</a> (T, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a12b96e58917d763e64eb4097c712d109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73045400315f8017e8977f547c0290ab"><td class="memTemplParams" colspan="2">template&lt;typename U , std::size_t SIZE&gt; </td></tr>
<tr class="memitem:a73045400315f8017e8977f547c0290ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE+SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a73045400315f8017e8977f547c0290ab">merge</a> (const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;, const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a73045400315f8017e8977f547c0290ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593341b5e0b89debf3e58c5e28dad6e1"><td class="memTemplParams" colspan="2">template&lt;typename U , std::size_t SIZE, std::size_t DIFF&gt; </td></tr>
<tr class="memitem:a593341b5e0b89debf3e58c5e28dad6e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE+DIFF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a593341b5e0b89debf3e58c5e28dad6e1">merge</a> (const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;, const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, DIFF &gt; &amp;, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a593341b5e0b89debf3e58c5e28dad6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ba691c5716a20d188032bf0ef75801"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42ba691c5716a20d188032bf0ef75801"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a42ba691c5716a20d188032bf0ef75801">merge</a> (const T &amp;, const T &amp;, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a42ba691c5716a20d188032bf0ef75801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8737b17dc612f59c6005bb25c597c322"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8737b17dc612f59c6005bb25c597c322"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a8737b17dc612f59c6005bb25c597c322">mergeSort</a> (const T &amp;, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a8737b17dc612f59c6005bb25c597c322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8748f5fc784d207a734b45b48bbb043e"><td class="memTemplParams" colspan="2">template&lt;typename U , std::size_t SIZE&gt; </td></tr>
<tr class="memitem:a8748f5fc784d207a734b45b48bbb043e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a8748f5fc784d207a734b45b48bbb043e">mergeSort</a> (const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a8748f5fc784d207a734b45b48bbb043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287004a744bc659675d309e2e786f96f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a287004a744bc659675d309e2e786f96f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#a287004a744bc659675d309e2e786f96f">quickSort</a> (const T &amp;, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:a287004a744bc659675d309e2e786f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368a945f1f910f746be3805b66b6136"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af368a945f1f910f746be3805b66b6136"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesalih_1_1algorithms.html#af368a945f1f910f746be3805b66b6136">selectionSort</a> (T, bool(*const order)(int, int)=<a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a>)</td></tr>
<tr class="separator:af368a945f1f910f746be3805b66b6136"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Searching algorihtms file. </p>
<dl class="section author"><dt>Author</dt><dd>Salih Mahmoud Sayed Ahmed @email <a href="#" onclick="location.href='mai'+'lto:'+'ahm'+'ed'+'233'+'@u'+'ni.'+'co'+'ven'+'tr'+'y.a'+'c.'+'uk'; return false;">ahmed<span style="display: none;">.nosp@m.</span>233@<span style="display: none;">.nosp@m.</span>uni.c<span style="display: none;">.nosp@m.</span>oven<span style="display: none;">.nosp@m.</span>try.a<span style="display: none;">.nosp@m.</span>c.uk</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 2021 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a107115c85af2697704dc3c5b36fde36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a107115c85af2697704dc3c5b36fde36d">&#9670;&nbsp;</a></span>ASCEND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool salih::algorithms::ASCEND </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This flag indicates 'smaller' value based on desire (for an ascending or descending list) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>(values to compare) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean if a is smaller, else false </dd></dl>

</div>
</div>
<a id="a58cfefbba1cc2773a2ea3cdc839d1747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cfefbba1cc2773a2ea3cdc839d1747">&#9670;&nbsp;</a></span>binarySearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool salih::algorithms::binarySearch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a binary search algorithm, which splits a list into sub-segments to look upon and repeats until the element is found </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (to be searched) </td></tr>
    <tr><td class="paramname">const</td><td>reference of target (to be identified in list) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean (indicates if supplied target was found or not) </dd></dl>

</div>
</div>
<a id="a12b96e58917d763e64eb4097c712d109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b96e58917d763e64eb4097c712d109">&#9670;&nbsp;</a></span>bubbleSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T salih::algorithms::bubbleSort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the bubble-sort sort algorithm. It works by repeatedly swapping the adjacent elements if they are in wrong order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>of list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="aa8d1038265c73db15d7f7b0ead070cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d1038265c73db15d7f7b0ead070cc5">&#9670;&nbsp;</a></span>DESCEND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool salih::algorithms::DESCEND </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This flag indicates 'smaller' value based on desire (for an ascending or descending list) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>(values to compare) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean if a is larger, else false </dd></dl>

</div>
</div>
<a id="adb7da9a1227add1ebb665f33c309aaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7da9a1227add1ebb665f33c309aaa1">&#9670;&nbsp;</a></span>getMiddle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t salih::algorithms::getMiddle </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a useful inline function to obtain the 'middle index' value, based on a given size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>integer (size of list to determine middle of) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer ('middle' index) </dd></dl>

</div>
</div>
<a id="a571825f56776c7964a279acee993857f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571825f56776c7964a279acee993857f">&#9670;&nbsp;</a></span>interpolationSearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool salih::algorithms::interpolationSearch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the interpolation search algorithm, I don't exactly know how to explain this one but it works </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (to be searched) </td></tr>
    <tr><td class="paramname">const</td><td>reference of target (to be identified in list) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean (indicates if supplied target was found or not) </dd></dl>

</div>
</div>
<a id="a8644274376f729c02cbfc2e8771688ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8644274376f729c02cbfc2e8771688ba">&#9670;&nbsp;</a></span>linearSearch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_GLIBCXX14_CONSTEXPR bool salih::algorithms::linearSearch </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a linear search algorithm, which iterates through a list until the end if need be </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (to be searched through) </td></tr>
    <tr><td class="paramname">const</td><td>reference of target (to be identified in list) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean (indicates if supplied target was found or not) </dd></dl>

</div>
</div>
<a id="a4ad8f696fdcdbeba1793aa531b7f0e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad8f696fdcdbeba1793aa531b7f0e0a">&#9670;&nbsp;</a></span>linearSearch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UniDirectionalIterator , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_GLIBCXX14_CONSTEXPR bool salih::algorithms::linearSearch </td>
          <td>(</td>
          <td class="paramtype">const UniDirectionalIterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UniDirectionalIterator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a linear search algorithm, which iterates through a list until the end if need be </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to iterator to beginning of search range </td></tr>
    <tr><td class="paramname">const</td><td>reference to iterator to end of search range </td></tr>
    <tr><td class="paramname">const</td><td>reference of target (to be identified in list) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean (indicates if supplied target was found or not) </dd></dl>

</div>
</div>
<a id="a593341b5e0b89debf3e58c5e28dad6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593341b5e0b89debf3e58c5e28dad6e1">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , std::size_t SIZE, std::size_t DIFF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt;U, SIZE+DIFF&gt; salih::algorithms::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, DIFF &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merging subroutine - it works by taking two lists and adding the smallest / the largest value from each, such that the resulting list is a combined list in order This subroutine is an overload specifically for two given Array class' whereby they are of a different size, which cannot use the generic list version due to the need of compile-time setup / preallocation, which other containers have no need or capability of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (one of the lists) </td></tr>
    <tr><td class="paramname">const</td><td>reference to list (another list) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a73045400315f8017e8977f547c0290ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73045400315f8017e8977f547c0290ab">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , std::size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt;U, SIZE+SIZE&gt; salih::algorithms::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merging subroutine - it works by taking two lists and adding the smallest / the largest value from each, such that the resulting list is a combined list in order This subroutine is an overload specifically for two given Array class' whereby they are of the same size, which cannot use the generic list version due to the need of compile-time setup / preallocation, which other containers have no need or capability of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (one of the lists) </td></tr>
    <tr><td class="paramname">const</td><td>reference to list (another list) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a42ba691c5716a20d188032bf0ef75801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ba691c5716a20d188032bf0ef75801">&#9670;&nbsp;</a></span>merge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T salih::algorithms::merge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merging subroutine - it works by taking two lists and adding the smallest / the largest value from each, such that the resulting list is a combined list in order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (one of the lists) </td></tr>
    <tr><td class="paramname">const</td><td>reference to list (another list) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a8748f5fc784d207a734b45b48bbb043e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8748f5fc784d207a734b45b48bbb043e">&#9670;&nbsp;</a></span>mergeSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , std::size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt;U, SIZE&gt; salih::algorithms::mergeSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsalih_1_1containers_1_1Array.html">salih::containers::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merge sort algorithm. It works splitting a list into minimal sublists and combining two, in order, into a bigger list. It keeps merging the lists together, then the merged lists together, until a fully sorted list is formed This algorithm is an overload specifically for a given Array class', which cannot use the generic list version due to the need of compile-time setup / preallocation, which other containers have no need or capability of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>refernece to list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a8737b17dc612f59c6005bb25c597c322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8737b17dc612f59c6005bb25c597c322">&#9670;&nbsp;</a></span>mergeSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T salih::algorithms::mergeSort </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merge sort algorithm. It works splitting a list into minimal sublists and combining two, in order, into a bigger list. It keeps merging the lists together, then the merged lists together, until a fully sorted list is formed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>refernece to list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a287004a744bc659675d309e2e786f96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287004a744bc659675d309e2e786f96f">&#9670;&nbsp;</a></span>quickSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T salih::algorithms::quickSort </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the quick sort algorithm. It creates three empty arrays to hold elements less than the pivot value, the same as the pivot value and elements greater than the pivot value, and then recursively sort the sub arrays and adds them together </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>of list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="af368a945f1f910f746be3805b66b6136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af368a945f1f910f746be3805b66b6136">&#9670;&nbsp;</a></span>selectionSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T salih::algorithms::selectionSort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the double-ended selection sort algorithm. It works by sorting a list of values by finding the smallest value from unsorted section and putting it at the end of the first sorted section &amp; has an additional sorted subsection containing the largest values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>of list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either <a class="el" href="namespacesalih_1_1algorithms.html#a107115c85af2697704dc3c5b36fde36d">salih::algorithms::ASCEND</a> (1,...,n) or <a class="el" href="namespacesalih_1_1algorithms.html#aa8d1038265c73db15d7f7b0ead070cc5">salih::algorithms::DESCEND</a> (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="ad9465eebd27e97b93e21aba605740844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9465eebd27e97b93e21aba605740844">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void salih::algorithms::swap </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function swaps the position of two elements (in a list structure) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>(reference to element we wish to swap with y </td></tr>
    <tr><td class="paramname">y</td><td>(references to elements we wish to swap with x) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
