<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Salih&#39;s Template Library (STL): Salih::Algorithms::Sorts Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Salih&#39;s Template Library (STL)
   </div>
   <div id="projectbrief">Salih&#39;s Template Library (STL) is a custom C++ Library inspired by STL (C++&#39;s standard template library), Boost, Common Algorithms / Data structures &amp; Python abstraction</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Salih</b></li><li class="navelem"><b>Algorithms</b></li><li class="navelem"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html">Sorts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Salih::Algorithms::Sorts Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8e0482f7a377567def8d56f1a5b5d32"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae8e0482f7a377567def8d56f1a5b5d32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a> (U, U)</td></tr>
<tr class="separator:ae8e0482f7a377567def8d56f1a5b5d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af739bdc2d0bb02a7cb1d0b3ce513c73b"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af739bdc2d0bb02a7cb1d0b3ce513c73b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#af739bdc2d0bb02a7cb1d0b3ce513c73b">DESCEND</a> (U, U)</td></tr>
<tr class="separator:af739bdc2d0bb02a7cb1d0b3ce513c73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89a10cd3343b8fc899d33541b61af65"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af89a10cd3343b8fc899d33541b61af65"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#af89a10cd3343b8fc899d33541b61af65">swap</a> (U &amp;, U &amp;)</td></tr>
<tr class="separator:af89a10cd3343b8fc899d33541b61af65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0afdd84df7ef17a1908991c4cd0f0e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </td></tr>
<tr class="memitem:aa0afdd84df7ef17a1908991c4cd0f0e7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#aa0afdd84df7ef17a1908991c4cd0f0e7">bubbleSort</a> (T list, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:aa0afdd84df7ef17a1908991c4cd0f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb7b3985e91063e0a1008f84ef91a80"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;Salih::Types::Traits::getDimensions&lt;U&gt;::value==0,U&gt;::type, std::size_t SIZE&gt; </td></tr>
<tr class="memitem:a4eb7b3985e91063e0a1008f84ef91a80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE+SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#a4eb7b3985e91063e0a1008f84ef91a80">merge</a> (const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;x, const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;y, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:a4eb7b3985e91063e0a1008f84ef91a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d34e012a9e3aa009429499e16e7b6b"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;Salih::Types::Traits::getDimensions&lt;U&gt;::value==0,U&gt;::type, std::size_t SIZE, std::size_t DIFF&gt; </td></tr>
<tr class="memitem:af1d34e012a9e3aa009429499e16e7b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE+DIFF &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#af1d34e012a9e3aa009429499e16e7b6b">merge</a> (const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;x, const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, DIFF &gt; &amp;y, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:af1d34e012a9e3aa009429499e16e7b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb4002115aceda65f2912a8ca5ca0e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::isDynamic&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </td></tr>
<tr class="memitem:a8eb4002115aceda65f2912a8ca5ca0e7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#a8eb4002115aceda65f2912a8ca5ca0e7">merge</a> (const T &amp;x, const T &amp;y, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:a8eb4002115aceda65f2912a8ca5ca0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab584b751411215fc470345f4601cad33"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::isDynamic&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </td></tr>
<tr class="memitem:ab584b751411215fc470345f4601cad33"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ab584b751411215fc470345f4601cad33">mergeSort</a> (const T &amp;data, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:ab584b751411215fc470345f4601cad33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a2fce60c16b724ae09454922ef29e6"><td class="memTemplParams" colspan="2">template&lt;typename U , typename  = typename std::enable_if&lt;Salih::Types::Traits::getDimensions&lt;U&gt;::value==0,U&gt;::type, std::size_t SIZE&gt; </td></tr>
<tr class="memitem:a50a2fce60c16b724ae09454922ef29e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#a50a2fce60c16b724ae09454922ef29e6">mergeSort</a> (const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;data, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:a50a2fce60c16b724ae09454922ef29e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac227e09c4ccddf73163e44b10259104"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::isDynamic&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </td></tr>
<tr class="memitem:aac227e09c4ccddf73163e44b10259104"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#aac227e09c4ccddf73163e44b10259104">quickSort</a> (const T &amp;list, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:aac227e09c4ccddf73163e44b10259104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131cab16ba495ddb4e7b849c187a099d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </td></tr>
<tr class="memitem:a131cab16ba495ddb4e7b849c187a099d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#a131cab16ba495ddb4e7b849c187a099d">selectionSort</a> (T list, bool(*const order)(int, int)=<a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a>)</td></tr>
<tr class="separator:a131cab16ba495ddb4e7b849c187a099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Flags for sorting algorithms. </p>
<p>Selection sort algorithm file.</p>
<p>Quick sort algorithm file.</p>
<p>Merge sort algorithm file.</p>
<p>Bubble sort algorithm file.</p>
<p>Swapping functionality for sorting algorithms.</p>
<dl class="section author"><dt>Author</dt><dd>Salih Mahmoud Sayed Ahmed @email <a href="#" onclick="location.href='mai'+'lto:'+'ahm'+'ed'+'233'+'@u'+'ni.'+'co'+'ven'+'tr'+'y.a'+'c.'+'uk'; return false;">ahmed<span style="display: none;">.nosp@m.</span>233@<span style="display: none;">.nosp@m.</span>uni.c<span style="display: none;">.nosp@m.</span>oven<span style="display: none;">.nosp@m.</span>try.a<span style="display: none;">.nosp@m.</span>c.uk</a> </dd></dl>
<dl class="section date"><dt>Date</dt><dd>May 2021 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae8e0482f7a377567def8d56f1a5b5d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e0482f7a377567def8d56f1a5b5d32">&#9670;&nbsp;</a></span>ASCEND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Salih::Algorithms::Sorts::ASCEND </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This flag indicates 'smaller' value based on desire (for an ascending or descending list) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>(values to compare) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean if a is smaller, else false </dd></dl>

</div>
</div>
<a id="aa0afdd84df7ef17a1908991c4cd0f0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0afdd84df7ef17a1908991c4cd0f0e7">&#9670;&nbsp;</a></span>bubbleSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Salih::Algorithms::Sorts::bubbleSort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the bubble-sort sort algorithm. It works by repeatedly swapping the adjacent elements if they are in wrong order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>of list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="af739bdc2d0bb02a7cb1d0b3ce513c73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af739bdc2d0bb02a7cb1d0b3ce513c73b">&#9670;&nbsp;</a></span>DESCEND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Salih::Algorithms::Sorts::DESCEND </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This flag indicates 'smaller' value based on desire (for an ascending or descending list) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>(values to compare) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean if a is larger, else false </dd></dl>

</div>
</div>
<a id="af1d34e012a9e3aa009429499e16e7b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d34e012a9e3aa009429499e16e7b6b">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;Salih::Types::Traits::getDimensions&lt;U&gt;::value==0,U&gt;::type, std::size_t SIZE, std::size_t DIFF&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt;U, SIZE+DIFF&gt; Salih::Algorithms::Sorts::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, DIFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the merging subroutine - it works by taking two lists and adding the smallest / the largest value from each, such that the resulting list is a combined list in order This subroutine is an overload specifically for two given Array class' whereby they are of a different size, which cannot use the generic list version due to the need of compile-time setup / preallocation, which other containers have no need or capability of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (one of the lists) </td></tr>
    <tr><td class="paramname">const</td><td>reference to list (another list) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a4eb7b3985e91063e0a1008f84ef91a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb7b3985e91063e0a1008f84ef91a80">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;Salih::Types::Traits::getDimensions&lt;U&gt;::value==0,U&gt;::type, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt;U, SIZE+SIZE&gt; Salih::Algorithms::Sorts::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the merging subroutine - it works by taking two lists and adding the smallest / the largest value from each, such that the resulting list is a combined list in order This subroutine is an overload specifically for two given Array class' whereby they are of the same size, which cannot use the generic list version due to the need of compile-time setup / preallocation, which other containers have no need or capability of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (one of the lists) </td></tr>
    <tr><td class="paramname">const</td><td>reference to list (another list) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a8eb4002115aceda65f2912a8ca5ca0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb4002115aceda65f2912a8ca5ca0e7">&#9670;&nbsp;</a></span>merge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::isDynamic&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Salih::Algorithms::Sorts::merge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the merging subroutine - it works by taking two lists and adding the smallest / the largest value from each, such that the resulting list is a combined list in order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>reference to list (one of the lists) </td></tr>
    <tr><td class="paramname">const</td><td>reference to list (another list) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a50a2fce60c16b724ae09454922ef29e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a2fce60c16b724ae09454922ef29e6">&#9670;&nbsp;</a></span>mergeSort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U , typename  = typename std::enable_if&lt;Salih::Types::Traits::getDimensions&lt;U&gt;::value==0,U&gt;::type, std::size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt;U, SIZE&gt; Salih::Algorithms::Sorts::mergeSort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSalih_1_1Structures_1_1Contiguous_1_1Array.html">Salih::Structures::Contiguous::Array</a>&lt; U, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merge sort algorithm. It works splitting a list into minimal sublists and combining two, in order, into a bigger list. It keeps merging the lists together, then the merged lists together, until a fully sorted list is formed This algorithm is an overload specifically for a given Array class', which cannot use the generic list version due to the need of compile-time setup / preallocation, which other containers have no need or capability of </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>refernece to list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="ab584b751411215fc470345f4601cad33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab584b751411215fc470345f4601cad33">&#9670;&nbsp;</a></span>mergeSort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::isDynamic&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Salih::Algorithms::Sorts::mergeSort </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the merge sort algorithm. It works splitting a list into minimal sublists and combining two, in order, into a bigger list. It keeps merging the lists together, then the merged lists together, until a fully sorted list is formed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>refernece to list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="aac227e09c4ccddf73163e44b10259104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac227e09c4ccddf73163e44b10259104">&#9670;&nbsp;</a></span>quickSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::isDynamic&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Salih::Algorithms::Sorts::quickSort </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the quick sort algorithm. It creates three empty arrays to hold elements less than the pivot value, the same as the pivot value and elements greater than the pivot value, and then recursively sort the sub arrays and adds them together </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>of list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="a131cab16ba495ddb4e7b849c187a099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131cab16ba495ddb4e7b849c187a099d">&#9670;&nbsp;</a></span>selectionSort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt; (Salih::Types::Traits::isList&lt;T&gt;::value &amp;&amp; Salih::Types::Traits::getDimensions&lt;T&gt;::value == 1), T &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Salih::Algorithms::Sorts::selectionSort </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(int, int)&#160;</td>
          <td class="paramname"><em>order</em> = <code><a class="el" href="namespaceSalih_1_1Algorithms_1_1Sorts.html#ae8e0482f7a377567def8d56f1a5b5d32">ASCEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the double-ended selection sort algorithm. It works by sorting a list of values by finding the smallest value from unsorted section and putting it at the end of the first sorted section &amp; has an additional sorted subsection containing the largest values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>of list (to be sorted) </td></tr>
    <tr><td class="paramname">const</td><td>function pointer, will facilitate ordering of list. Set as either ASCEND (1,...,n) or DESCEND (n,...,1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list (sorted version) </dd></dl>

</div>
</div>
<a id="af89a10cd3343b8fc899d33541b61af65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89a10cd3343b8fc899d33541b61af65">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Salih::Algorithms::Sorts::swap </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function swaps the position of two elements (in a list structure) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>(references to elements (of a list) we wish to swap) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
